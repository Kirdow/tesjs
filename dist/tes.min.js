var TES=(()=>{var $=(a=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(a,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):a)(function(a){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+a+'" is not supported')});var d=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports);var U=d(()=>{});var g=d((be,A)=>{var j={debug:0,error:1,warn:2,info:3,none:4},L="warn",k=a=>e=>{j[a]>=j[L]&&console.log(`${new Date().toUTCString()} - TESjs - ${e}`)};A.exports={setLevel:a=>L=a,debug:k("debug"),error:k("error"),warn:k("warn"),log:k("info")}});var S=d((we,x)=>{var K=g(),_=class{constructor(){_._instance=this,this._events=this._events||{},this._subscriptionQueue=this._subscriptionQueue||{}}fire(e,t){let n=this._events[e.type];return n?(n.call(this,t,e),!0):(K.warn(`Recieved event for unhandled type: ${e.type}`),!1)}addListener(e,t){if(typeof t!="function")throw TypeError("Event handler must be a function");return this._events[e]=t,this}removeListener(e){return this._events[e]&&delete this._events[e],this}removeAllListeners(){return this._events={},this}queueSubscription(e,t,n){let s=e.data[0].id;return this._subscriptionQueue[s]={data:e,resolve:t,timeout:setTimeout(()=>{n({message:"Subscription verification timed out, this will need to be cleaned up",subscriptionID:s}),delete this._subscriptionQueue[s]},6e5)},this}resolveSubscription(e){if(!this._subscriptionQueue[e])return this;let{resolve:t,timeout:n,data:s}=this._subscriptionQueue[e];return clearTimeout(n),t(s),delete this._subscriptionQueue[e],this}},X=new _;x.exports=X});var E=d((ge,W)=>{W.exports={objectShallowEquals:(a,e)=>{let t=Object.entries(a).every(([n,s])=>!(!(n in e)||s!==e[n]));return t&&(t=Object.entries(e).every(([n,s])=>!(!(n in a)||a[n]!==s))),t},printObject:a=>JSON.stringify(a)}});var C=d((_e,B)=>{var Y=typeof global<"u"?global:typeof window<"u"?window:{},Z=Y.WebSocket||$("../node_modules/ws/index.js"),I=S(),l=g(),{objectShallowEquals:ee}=E(),te="wss://eventsub-beta.wss.twitch.tv/ws",b=class{constructor(){if(b._instance)return b._instance;b._instance=this,this._connections={}}async getFreeConnection(){l.debug("Getting free WebSocket connection");let e=Object.keys(this._connections).find(t=>Object.keys(this._connections[t].subscriptions).length<100);if(e)return l.debug(`Found free WebSocket connection "${e}"`),e;if(Object.keys(this._connections).length<3)return l.debug("No free WebSocket connections, creating a new one..."),new Promise(t=>this._addConnection(t));throw l.debug("No free WebSocket connections, maximum number of connections reached"),new Error("Maximum number of WebSocket connections reached")}removeSubscription(e){Object.values(this._connections).forEach(t=>delete t.subscriptions[e])}addSubscription(e,{id:t,type:n,condition:s}){this._connections[e].subscriptions[t]={type:n,condition:s}}findSubscriptionID(e,t){for(let n in this._connections){let s=this._connections[n],i=Object.keys(s.subscriptions).find(c=>(subscription=s.subscriptions[c],subscription.type===e&&ee(subscription.condition,t)));if(i)return i}}_addConnection(e,t=te){let n=new Z(t);return n.onmessage=s=>{let{metadata:{message_type:i},payload:c}=JSON.parse(s.data);if(i==="session_welcome"){let{session:{id:o,keepalive_timeout_seconds:r}}=c;l.debug(`Received welcome message for session "${o}"`),n.resetTimeout=()=>{n.keepaliveTimeout&&clearTimeout(n.keepaliveTimeout),n.keepaliveTimeout=setTimeout(()=>{I.fire({type:"connection_lost"},n.subscriptions),delete this._connections[o]},r*1e3+100)},n.subscriptions={},this._connections[o]=n,n.resetTimeout(),e(o)}else if(i==="session_keepalive")n.resetTimeout();else if(i==="session_reconnect"){let{session:{id:o,reconnect_url:r}}=c;l.debug(`Received reconnect message for session "${o}"`),this._addConnection(()=>n.close(),r)}else if(i==="notification"){n.resetTimeout();let{subscription:o,event:r}=c;l.log(`Received notification for type ${o.type}`),I.fire(o,r)}else if(i==="revocation"){n.resetTimeout();let{subscription:o}=c;l.log(`Received revocation notification for subscription id ${o.id}`),I.fire({...o,type:"revocation"},o),this.removeSubscription(o.id)}else l.log(`Unhandled WebSocket message type "${i}"`)},n.onclose=s=>{let[i]=Object.entries(this._connections).find(([r,u])=>u===n)||[],{code:c,reason:o}=s;l.debug(`WebSocket connection "${i}" closed. ${c}:${o}`),delete this._connections[i]},n}};B.exports=b});var q=d((me,G)=>{var ne=typeof global<"u"?global:typeof window<"u"?window:{},P=ne.fetch||$("../node_modules/node-fetch/browser.js"),m=g(),F="https://id.twitch.tv/oauth2",f=class{constructor({clientID:e,clientSecret:t,onAuthFailure:n,initialToken:s,refreshToken:i}){if(this._isWebClient=typeof window<"u",!n&&!this._isWebClient&&(!e||!t))throw new Error("AuthManager config must contain client ID and secret if onAuthFailure not defined");if(f._instance)return f._instance;f._instance=this,this._clientID=e,this._clientSecret=t,this._validationInterval,this._customRefresh=n,this._refreshToken=i,s?this._authToken=s:this.refreshToken()}static getInstance(){return f._instance}getToken(){return new Promise((e,t)=>{let n=new Date,s=()=>{if(this._authToken)e(this._authToken);else if(new Date-n>1e6){let i="Timed out trying to get token";m.error(`${i}.  Something catastrophic has happened!`),t(i)}else setTimeout(s)};s()})}async refreshToken(){m.debug("Getting new app access token");try{if(this._authToken=void 0,this._isWebClient)throw new Error("cannot refresh access token on web client");if(this._customRefresh)this._authToken=await this._customRefresh();else{let e="",t="client_credentials";this._refreshToken&&(t="refresh_token",e=`&refresh_token=${this._refreshToken}`);let n=await P(`${F}/token?client_id=${this._clientID}&client_secret=${this._clientSecret}&grant_type=${t}${e}`,{method:"POST"});if(n.ok){let{access_token:s,refresh_token:i}=await n.json();this._authToken=s,this._refreshToken=i,this._resetValidationInterval()}else{let{message:s}=await n.json();throw new Error(s)}}}catch(e){throw m.error(`Error refreshing app access token: ${e.message}`),e}}async _validateToken(){m.debug("Validating app access token");let e={"client-id":this.clientID,Authorization:`Bearer ${this._authToken}`};(await P(`${F}/validate`,{headers:e})).status===401&&(m.debug("Access token not valid, refreshing..."),this.refreshToken())}_resetValidationInterval(){clearInterval(this._validationInterval),this._validationInterval=setInterval(this._validateToken,36e5)}};G.exports=f});var z=d((ye,Q)=>{var se=typeof global<"u"?global:typeof window<"u"?window:{},ie=se.fetch||$("../node_modules/node-fetch/browser.js"),oe=q(),re=g(),y=class{constructor(){y._instance=this}async request(e,t,n=!0){let s=async()=>{let i=await ie(e,t);if(i.status===401){re.debug("Request received 401 unauthorized response. Refreshing token and retrying...");let c=oe.getInstance();try{await c.refreshToken()}catch(o){if(!o.message.includes("web client"))throw o;return i.json()}return t.headers.Authorization=`Bearer ${await c.getToken()}`,s()}else return n?i.json():i.text()};return s()}},ce=new y;Q.exports=ce});var le=d((ve,J)=>{var ae=U(),ue=C(),N=S(),T=q(),D=z(),{objectShallowEquals:he,printObject:O}=E(),h=g(),v="https://api.twitch.tv/helix/eventsub/subscriptions",w=class{constructor(e){if(w._instance)return w._instance;if(!e.identity)throw new Error("TES config must contain 'identity'");if(!e.listener)throw new Error("TES config must contain 'listener'");let{identity:{id:t,secret:n,onAuthenticationFailure:s,accessToken:i,refreshToken:c},listener:{type:o,baseURL:r,secret:u,port:p,ignoreDuplicateMessages:M,ignoreOldMessages:V,server:R}}=e;if(!o||o!=="webhook"&&o!=="websocket")throw new Error("TES listener config must have 'type' either 'webhook' or 'websocket'");if(!t)throw new Error("TES identity config must contain 'id'");if(o==="webhook"){if(!n)throw new Error("TES identity config must contain 'secret'");if(!r)throw new Error("TES listener config must contain 'baseURL'");if(!u)throw new Error("TES listener config must contain 'secret'")}else{if(!i)throw new Error("TES identity config must contain 'accessToken'");if(typeof window>"u"&&!s&&!c)throw new Error("TES identity config must contain either 'onAuthenticationFailure' or 'refreshToken'");if(c&&!n)throw new Error("TES identity config must contain 'secret'")}if(w._instance=this,this.clientID=t,this.transportType=o,o==="webhook"){this.baseURL=r,this.whSecret=u,this.port=p||process.env.PORT||8080;let H={ignoreDuplicateMessages:M!==!1,ignoreOldMessages:V!==!1};this.whserver=ae(R,u,H),this._whserverlistener=R?null:this.whserver.listen(this.port)}else this.wsclient=new ue;e.options=e.options||{},e.options.debug&&h.setLevel("debug"),e.options.logging===!1&&h.setLevel("none"),new T({clientID:t,clientSecret:n,onAuthFailure:s,initialToken:i,refreshToken:c})}getSubscriptions(e){return h.debug(`Getting ${e?`subscriptions for cursor ${e}`:"first page of subscriptions"}`),this._getSubs(`${v}${e?`?after=${e}`:""}`)}getSubscriptionsByType(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} of type ${e}`),this._getSubs(`${v}?${`type=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}getSubscriptionsByStatus(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} with status ${e}`),this._getSubs(`${v}?${`status=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}async getSubscription(...e){if(e.length>2)throw new Error("getSubscription must have 1 or 2 arguments");let[t,n]=e;e.length===1?h.debug(`Getting subscription for id ${t}`):h.debug(`Getting subscription for type ${t} and condition ${O(n)}`);let s,i=async c=>{let o;e.length===1?o=await this.getSubscriptions(c):o=await this.getSubscriptionsByType(t,c);let{data:r,pagination:u}=o;s=r.find(p=>n?p.type===t&&he(p.condition,n):p.id===t),!s&&u.cursor&&await i(u.cursor)};return await i(),s}async subscribe(e,t){h.debug(`Subscribing to topic with type ${e} and condition ${O(t)}`);let n=await T.getInstance().getToken(),s={"client-id":this.clientID,Authorization:`Bearer ${n}`,"content-type":"application/json"},i={method:this.transportType};if(this.transportType==="webhook")i.callback=`${this.baseURL}/teswh/event`,i.secret=this.whSecret;else{let r=await this.wsclient.getFreeConnection();i.session_id=r}let c={type:e,condition:t,transport:i,version:"1"},o=await D.request(v,{method:"POST",body:JSON.stringify(c),headers:s});if(o.data){if(this.transportType==="webhook")return new Promise((r,u)=>N.queueSubscription(o,r,u));{let r=o.data[0];return this.wsclient.addSubscription(r.transport.session_id,r),r}}else{let{error:r,status:u,message:p}=o;throw new Error(`${u} ${r}: ${p}`)}}async unsubscribe(...e){let t=await T.getInstance().getToken(),n={"client-id":this.clientID,Authorization:`Bearer ${t}`},s=async i=>D.request(`${v}?id=${i}`,{method:"DELETE",headers:n},!1);if(arguments.length===1){let i=e[0];return h.debug(`Unsubscribing from topic ${i}`),s(i)}else if(arguments.length===2){let[i,c]=e;h.debug(`Unsubscribing from topic with type ${i} and condition ${O(c)}`);let o;if(this.transportType==="webhook"){let r=await this.getSubscription(i,c);r&&(o=r.id)}else o=this.wsclient.findSubscriptionID(i,c);if(o){if(this.transportType==="webhook")return s(o);{let r=await s(o);return r.ok&&this.wsclient.removeSubscription(o),r}}else throw new Error("subscription with given type and condition not found")}else throw new Error("unsubscribe must only have 1 or 2 arguments")}on(e,t){h.debug(`Adding notification listener for type ${e}`),N.addListener(e,t)}async _getSubs(e){let t=await T.getInstance().getToken(),n={"client-id":this.clientID,Authorization:`Bearer ${t}`};return D.request(e,{headers:n})}static ignoreInMiddleware(e){return(t,n,s)=>t.path==="/teswh/event"?s():e(t,n,s)}};J.exports=w});return le();})();
//# sourceMappingURL=tes.min.js.map
